<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Mesh Spectrogram with Native Audio Controls</title>
  <style>
    /* fullscreen canvas */
    html, body {
      margin: 0 !important;
      padding: 0 !important;
      background: #000;
      height: 100%;
      overflow: hidden !important;
    }
    #three-canvas {
      position: fixed;
      top: 150px; left: 0;
      width: 100vw !important;
      height: 100vh !important;
      display: block;
      z-index: 1;
    }
    /* UI panel */
    #ui {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      background: rgba(255, 255, 255, 0.7);
      padding: 8px;
      border-radius: 4px;
      width: 300px;
      box-sizing: border-box;
    }
    /* Choose File + Reset same size */
    #ui input[type="file"],
    #ui button {
      width: 100%;
      height: 36px;          /* fixed height */
      padding: 6px 4px;
      margin: 2px 0;         /* minimal gap */
      display: block;
      box-sizing: border-box;
      font-size: 14px;
    }
    /* other UI elements */
    #ui audio {
      margin: 6px 0;
      width: 100%;
    }
    #ui label {
      margin: 6px 0;
      font-size: 14px;
      display: block;
    }
    #ui select {
      width: 100%;
      padding: 4px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <canvas id="three-canvas"></canvas>

  <div id="ui">
    <input type="file" id="audio-upload" accept=".mp3,.wav" />
    <button id="reset">Reset</button>
    <audio id="audio-player" controls></audio>
    <label for="colormap">Colormap:
      <select id="colormap">
        <option value="viridis" selected>Viridis</option>
        <option value="plasma">Plasma</option>
        <option value="gray">Gray</option>
      </select>
    </label>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "OrbitControls": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <script type="module">
  import * as THREE        from 'three';
  import { OrbitControls } from 'OrbitControls';

  // Renderer
  const canvas   = document.getElementById('three-canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  // Camera + Controls
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  const az     = -Math.PI/4, el = Math.PI/6, r = 150;
  camera.position.set(
    r * Math.sin(az) * Math.cos(el),
    r * Math.sin(el),
    r * Math.cos(az) * Math.cos(el)
  );
  camera.lookAt(0,0,0);
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enablePan = false;
  controls.update();

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 2.0));
  const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
  dirLight.position.set(50,100,50);
  scene.add(dirLight);

  // Spectrogram geometry
  const N = 256, M = 256;
  const SPACING = 0.4, HEIGHT = 24, margin = SPACING*2;
  const totalY  = N*SPACING, maxLog = Math.log10(N);

  const planeGeo = new THREE.PlaneGeometry(M*SPACING, N*SPACING, M-1, N-1);
  planeGeo.rotateX(-Math.PI/2);
  const posArr = planeGeo.attributes.position.array;
  for (let row=0; row<N; row++) {
    const lp = Math.log10(1+row)/maxLog;
    for (let col=0; col<M; col++) {
      const i = (row*M + col)*3;
      posArr[i+2] = -totalY/2 + margin + lp*(totalY-margin);
    }
  }
  planeGeo.attributes.position.needsUpdate = true;

  // Color buffer
  const colorAttr = new THREE.BufferAttribute(new Float32Array(posArr.length), 3);
  planeGeo.setAttribute('color', colorAttr);
  const colArr = colorAttr.array;

  // Mesh material
  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    flatShading: true,
    roughness: 0.0,
    metalness: 0.7
  });
  const mesh = new THREE.Mesh(planeGeo, material);
  scene.add(mesh);

  // Colormap functions
  const cmap = document.getElementById('colormap');
  const colormaps = {
    viridis: v=>{ v=THREE.MathUtils.clamp(v,0,1); return new THREE.Color().setHSL(0.7-0.7*v,1,0.5); },
    plasma:  v=>{ v=THREE.MathUtils.clamp(v,0,1); const rv=1-v; return new THREE.Color().setHSL(0.9-0.6*rv,1,0.5); },
    gray:    v=>{ v=THREE.MathUtils.clamp(v,0,1); return new THREE.Color(v,v,v); }
  };
  function getColor(v){ return colormaps[cmap.value](v); }

  // UI elements
  const fileIn = document.getElementById('audio-upload');
  const audio  = document.getElementById('audio-player');
  const reset  = document.getElementById('reset');

  let audioCtx, analyser, dataArray, sourceNode;
  let spectrogram = Array(M).fill().map(()=>new Uint8Array(N));
  let frame=0, tick=0, ended=false, endCount=0;

  // Reset handler
  reset.addEventListener('click', ()=>window.location.reload());
  fileIn.addEventListener('click', ()=>fileIn.value='');

  // Load & play audio + FFT
  fileIn.addEventListener('change', async () => {
    const file = fileIn.files[0];
    if (!file) return;

    // clear previous data
    spectrogram = Array(M).fill().map(()=>new Uint8Array(N));
    frame = tick = endCount = 0;
    ended = false;
    for (let i=0; i<posArr.length; i+=3) {
      posArr[i+1] = 0;
      colArr[i] = colArr[i+1] = colArr[i+2] = 0;
    }
    planeGeo.attributes.position.needsUpdate = true;
    planeGeo.attributes.color.needsUpdate    = true;

    // native audio playback
    audio.src = URL.createObjectURL(file);
    await new Promise(r=>audio.onloadedmetadata = r);
    audio.play();

    // Web Audio FFT
    audioCtx     = new (window.AudioContext||window.webkitAudioContext)();
    analyser     = audioCtx.createAnalyser();
    analyser.fftSize = N*4;
    dataArray    = new Uint8Array(analyser.frequencyBinCount);
    sourceNode   = audioCtx.createMediaElementSource(audio);
    sourceNode.connect(analyser);
    analyser.connect(audioCtx.destination);
    audio.onended = ()=>ended = true;

    // start loops
    requestAnimationFrame(updateMesh);
    requestAnimationFrame(render);
  });

  // Mesh update
  function updateMesh(){
    requestAnimationFrame(updateMesh);
    if (audio.paused && !ended) return;
    if (++tick % 2) return;

    analyser.getByteFrequencyData(dataArray);
    spectrogram[ frame % M ] = Uint8Array.from(dataArray.subarray(0,N));
    frame++;

    for (let f=0; f<N; f++){
      for (let t=0; t<M; t++){
        const idx = (f*M + t)*3;
        const v   = spectrogram[(frame-1-t+M)%M][f] / 255;
        posArr[idx+1] = v * HEIGHT;
        const c = getColor(v);
        colArr[idx]   = c.r;
        colArr[idx+1] = c.g;
        colArr[idx+2] = c.b;
      }
    }
    planeGeo.attributes.position.needsUpdate = true;
    planeGeo.attributes.color.needsUpdate    = true;

    if (ended && ++endCount >= M) window.location.reload();
  }

  // Render loop
  function render(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

  window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight - 80);
    camera.aspect = window.innerWidth/(window.innerHeight-80);
    camera.updateProjectionMatrix();
  });

  render();
  </script>
</body>
</html>
