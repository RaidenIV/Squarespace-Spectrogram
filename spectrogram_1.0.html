<body>
  <div id="ui">
    <input type="file" id="audio-upload" accept=".mp3,.wav" />
    <!-- native controls: play/pause/seek built-in -->
    <audio id="audio-player" controls></audio>
    <label for="colormap">Colormap:
      <select id="colormap">
        <option value="inferno">Inferno</option>
        <option value="viridis" selected>Viridis</option>
        <option value="plasma">Plasma</option>
        <option value="gray">Gray</option>
      </select>
    </label>
    <button id="reset">ðŸ”„ Reset</button>
  </div>

  <canvas id="three-canvas"></canvas>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "OrbitControls": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'OrbitControls';

  // â€” Renderer / Scene / Camera â€”
  const canvas   = document.getElementById('three-canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  const scene    = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
  const az = THREE.MathUtils.degToRad(-45),
        el = THREE.MathUtils.degToRad(30),
        r  = 175;
  camera.position.set(
    r * Math.sin(az)*Math.cos(el),
    r * Math.sin(el),
    r * Math.cos(az)*Math.cos(el)
  );
  camera.lookAt(0,0,0);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enablePan = controls.enableDamping = false;
  controls.update();

  scene.add(new THREE.AmbientLight(0xffffff,0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
  dirLight.position.set(50,100,50);
  scene.add(dirLight);

  // â€” Spectrogram parameters â€”
  const N = 256, M = 256;
  const SPACING = 0.4, HEIGHT = 24;
  const maxLog = Math.log10(N);
  const freqMap = new Uint16Array(N).map((_,i) => i);

  // â€” Colormap â€”
  const cmapSelect = document.getElementById('colormap');
  function inferno(v){ v=THREE.MathUtils.clamp(v,0,1); return new THREE.Color(Math.pow(v,0.25),Math.pow(v,0.75)*0.4,v*0.3); }
  function viridis(v){ v=THREE.MathUtils.clamp(v,0,1); return new THREE.Color().setHSL(0.7-0.7*v,1,0.5); }
  function plasma(v){ v=THREE.MathUtils.clamp(v,0,1); const rv=1-v; return new THREE.Color().setHSL(0.9-0.6*rv,1,0.5); }
  function gray(v){ v=THREE.MathUtils.clamp(v,0,1); return new THREE.Color(v,v,v); }
  function getColor(v){
    switch(cmapSelect.value){
      case 'viridis': return viridis(v);
      case 'plasma':  return plasma(v);
      case 'gray':    return gray(v);
      default:        return inferno(v);
    }
  }

  // â€” Build mesh â€”
  const plane = new THREE.PlaneGeometry(M*SPACING, N*SPACING, M-1, N-1);
  plane.rotateX(-Math.PI/2);
  const posArr = plane.attributes.position.array;
  // semi-log freq axis:
  const margin    = SPACING * 2;
  const totalSpan = N * SPACING;
  for (let row=0; row<N; row++){
    const logProj = Math.log10(1+row)/maxLog;
    for (let col=0; col<M; col++){
      const idx = (row*M+col)*3;
      posArr[idx+2] = -totalSpan/2 + margin + logProj*(totalSpan-margin);
    }
  }
  plane.attributes.position.needsUpdate = true;

  const colArr = new Float32Array(posArr.length);
  plane.setAttribute('color', new THREE.BufferAttribute(colArr,3));
  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    flatShading: true
  });
  scene.add(new THREE.Mesh(plane, material));

  // â€” Audio / FFT setup â€”
  const fileIn      = document.getElementById('audio-upload');
  const audioPlayer = document.getElementById('audio-player');
  const resetBtn    = document.getElementById('reset');

  let audioCtx, analyser, dataArray, sourceNode;
  let spectBuffer = Array(M).fill().map(()=>new Uint8Array(N));
  let frame = 0, tick = 0, audioEnded = false, endCount = 0;

  resetBtn.addEventListener('click', ()=> window.location.reload());
  fileIn.addEventListener('click', ()=> fileIn.value = '');

  fileIn.addEventListener('change', async e => {
    const file = e.target.files[0];
    if (!file) return;

    // set up native audio
    audioPlayer.src = URL.createObjectURL(file);
    await new Promise(r=>audioPlayer.onloadedmetadata = r);
    audioPlayer.play();

    // Web Audio for FFT
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = N * 4;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    sourceNode = audioCtx.createMediaElementSource(audioPlayer);
    sourceNode.connect(analyser);
    analyser.connect(audioCtx.destination);

    audioPlayer.onended = ()=> audioEnded = true;

    requestAnimationFrame(updateMesh);
    requestAnimationFrame(render);
  });

  function updateMesh(){
    requestAnimationFrame(updateMesh);
    if (audioPlayer.paused && !audioEnded) return;
    if (++tick % 2) return;  // ~30fps

    analyser.getByteFrequencyData(dataArray);
    spectBuffer[ frame % M ] = Uint8Array.from(dataArray.subarray(0,N));
    frame++;

    for (let f=0; f<N; f++){
      const fi = freqMap[f];
      for (let t=0; t<M; t++){
        const idx = (f*M+t)*3;
        const v   = spectBuffer[(frame-1-t+M)%M][fi] / 255;
        posArr[idx+1] = v * HEIGHT;
        const c = getColor(v);
        colArr[idx]   = c.r;
        colArr[idx+1] = c.g;
        colArr[idx+2] = c.b;
      }
    }

    plane.attributes.position.needsUpdate = true;
    plane.attributes.color.needsUpdate    = true;

    if (audioEnded && ++endCount >= M) {
      window.location.reload();
    }
  }

  function render(){
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });
  </script>
</body>
